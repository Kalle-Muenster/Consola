/*///////////////////////////////////////////////////////////*\
||                                                           ||
||     File:      ConsolaAuxilary.hpp                        ||
||     Author:    Autogenerated                              ||
||     Generated: 23.02.2022                                 ||
||                                                           ||
\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
#ifndef _ConsolaAuxilary_hpp_
#define _ConsolaAuxilary_hpp_

#include <.byteOrder.h>

using namespace System::Xml;


namespace Consola {
    
    ref class AuxXml;
 //   ref class AuxOut;
 //   ref class AuxLog;
 //   ref class AuxInp;

    public ref class AuxilaryStream : public StdStream
    {
    private:
        // eindimensionale, spheroide räume:
        static int extendRaum( fourCC des, Direction how ) {
            switch ( how ) {
            case Direction::Out: {
                int size = auxeen->Length;
                array<AuxilaryStream^>^ raumExtender = gcnew array<AuxilaryStream^>(auxtrm->Length + 1);
                array<fourCC>^ nameExtender = gcnew array<fourCC>(auxeen->Length + 1);
                auxtrm->CopyTo(raumExtender, 0);
                auxeen->CopyTo(nameExtender, 0);
                auxtrm = raumExtender;
                auxeen = nameExtender;
                auxeen[size] = des;
                return size;
            } break;
            case Direction::Inp: {
                if (auxtrm->Length > 1) {
                    int position = auxeen->Length-1;
                    array<AuxilaryStream^>^ raumExtender = gcnew array<AuxilaryStream^>(auxtrm->Length - 1);
                    array<fourCC>^ nameExtender = gcnew array<fourCC>(auxeen->Length - 1);
                    for (int i = position, n = position-1; i >= 0; --i, --n) {
                        if (auxeen[i] != des) {
                            raumExtender[n] = auxtrm[i];
                            nameExtender[n] = auxeen[i];
                        } else position = n++;
                    }
                    auxtrm = raumExtender;
                    auxeen = nameExtender;
                    return position;
                } else {
                    auxtrm = nullptr;
                    auxeen = nullptr;
                    return 0;
                }
            } break;
            default: how = Direction::Err; break;
            }
        }
    internal:
        static volatile uint lockvar = EMPTY;
       
        static array<fourCC>^          auxeen;
        static array<AuxilaryStream^>^ auxtrm;

        AuxilaryStream( fourCC name )
            : StdStream( Direction::Aux )
            , typ( name ) {
            if (auxeen == nullptr) {
                auxeen = gcnew array<fourCC>(1) { name };
                auxtrm = gcnew array<AuxilaryStream^>(1) { this };
                aux = this;
            } else auxtrm[ extendRaum( typ, Direction::Inp ) ] = this;
        }
        virtual ~AuxilaryStream() { extendRaum( typ, Direction::Out ); }
        virtual bool lockup(uint key) override {
            if (lockvar == EMPTY) {
                lockvar = key;
            } return lockvar == key;
        }
        virtual bool unlock(uint key) override {
            if (lockvar == key) {
                lockvar = EMPTY;
            } return lockvar == EMPTY;
        }
        virtual bool locked(void) override {
            return lockvar != EMPTY;
        }
    protected:
        const fourCC typ;
    public:
        property LogWriter^ Log {
            virtual LogWriter^ get(void) override {
                return log == nullptr
                     ? createLog() : log;
            }
            virtual void set( LogWriter^ value ) override {
                if (((log != nullptr) && (log != value)) || (value == nullptr)) {
                    closeLog();
                } log = value;
            }
        }
        virtual String^ ToString(void) override {
            return String::Format("{0}_{1}.log", this->nam, typ );
        }

        property AuxXml^ Xml {
            AuxXml^ get(void) { for (int idx = 0; idx < auxeen->Length; ++idx) if (auxeen[idx] == byteOrder_stringTOfourCC("Xml")) return (AuxXml^)auxtrm[idx]; return nullptr; }
        }
    };

    public ref class AuxXml : public AuxilaryStream
    {
    internal:
        AuxXml(void) : AuxilaryStream( byteOrder_stringTOfourCC("Xml") ) {
            scope = State::NoScope;
            depth = -1;
            state = nullptr;
        }


    public:
        enum class State { NoScope, Document, Element, Attribute, Content, CData, Comment };

        property bool IsInput { bool get(void); }
        
        int     WriteNode( System::Xml::XmlNode^ node );
        int     Write(System::Object^ content);
        int     WriteElement(String^ tagname, ...array<Object^>^ attribute);
        int     WriteAttribute(String^ name, Object^ value);
        generic<class T> where T : ValueType
        int     WriteData(array<T>^ data);
        


        virtual property LogWriter^ Log {
        public: LogWriter^ get(void) override {
            return log == nullptr
                ? createLog() : log;
        }
        public: void set(LogWriter^ logger) override {
            if (logger == nullptr) {
                closeLog();
            }
            else { log = logger; }
        }
        }

        property State Scope {
            State get(void);
        }

        void NewScope(State newScope) {
            switch (scope) {
            case State::Attribute:
                if ( (newScope & (State::Element | State::Content)) != State::NoScope ) log->Write('>');
                else { --depth; log->WriteLine("/>"); }
                scope = newScope;
                break;
            case State::Element:
                if (state != nullptr && !(newScope == State::Content))
                    log->WriteLine(String::Format("</{0}>", state));
                else log->WriteLine("/>");
                --depth;
                break;
            case State::Comment:
                log->WriteLine(" -->");
                --depth;
                break;
            case State::Content:
                if (newScope != State::Content) {
                    log->WriteLine(String::Format("</{0}>", state));
                    --depth;
                }
                break;
            case State::CData:
                log->WriteLine("\"]>");
                --depth;
            } scope = newScope;
        }

        property int Depth { int get(void) { return depth; } }

    private:
        int depth;
        State scope;
        String^ state;

    };

} //end of Consola

#endif
