/*///////////////////////////////////////////////////////////*\
||                                                           ||
||     File:      Parser.hpp                                 ||
||     Author:    autogenerated                              ||
||     Generated: by Command Generator v.0.1                 ||
||                                                           ||
\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
#ifndef _Parser_hpp_
#define _Parser_hpp_

namespace Consola
{
	generic<class E>
	public interface class IParser
	{
	public:
	    property bool Found { bool get( void ) abstract; }
	    property int Offset { int get( void ) abstract; }
	    
	    // translate an enumerators actual index position to a byte
	    // index position where last found search text match begins
	    int  FoundAt( int actualEnumeratorPosition ) abstract;
	    
	    // setup a search 'verb' which makes enumerator stopping
	    // as soon matching portion is found within cryptic data  
	    void SetSequence( Object^ sequence ) abstract;
	    Object^ GetSequence( void ) abstract;
	    
	    // Prepares the search parser for searching for further 
	    // ocurrences of same search verb after finding a match
	    bool Next( void ) abstract;
	    
	    // parses the next element ('Current' element) in progress
	    // returns: 'true' if search text is encounterd. otherwise 'false'.
	    bool Parse( E next ) abstract;
	    
	    // same like Parse() does, but returns just the passed current
	    // element as is. information about serach text was encounterd
	    // can be obtained via the 'Found' property which turns 'true' 
	    // with encontering the serch text.
	    E Check( E next ) abstract;
	};

	// interface for parsers which search in buffers of type 'T'
	// for a given sequence of elements in blocks of type 'E'
	// (for parsing strings by passing 4 chars at once as 32bit integer elements
	// these types should be given: T as 'string', E as 'uint'
	generic<class T, class E>
	public interface class IDataParser
		: public IParser<E> {
	public:
		property T Sequence {
				T get( void ) abstract;
				void set( T ) abstract;
		}
	};


	public ref class StreamParser 
		: public IDataParser<array<unsigned char>^,unsigned char>
	{
	private:
	
		int                   founds;
		array<unsigned char>^ bucket;
		array<unsigned char>^ search;

		bool nextByte( unsigned char next );

	public:

		property int Offset {
			virtual int get( void ) = IDataParser<array<unsigned char>^, unsigned char>::Offset::get;
		}

		property bool Found {
			virtual bool get( void ) { return founds == bucket->Length; }
		}

		virtual int FoundAt( int currentEnumeratorPosition ) {
			return 1 + ( currentEnumeratorPosition - search->Length ) + Offset;
		}

		virtual void SetSequence( Object^ sequence ) = IDataParser<array<unsigned char>^, unsigned char>::SetSequence {
			Sequence = safe_cast<array<unsigned char>^>( sequence );
		}

		virtual Object^ GetSequence( void ) = IDataParser<array<unsigned char>^, unsigned char>::GetSequence {
			return Sequence;
		}

		property array<unsigned char>^ Sequence {
			virtual array<unsigned char>^ get( void );
			virtual void set( array<unsigned char>^ value );
		}

		StreamParser( array<unsigned char>^ searchForSequence );
		virtual bool Parse( unsigned char next );
		virtual unsigned char Check( unsigned char next );
		virtual bool Next( void );
    };

} //end of namespace Consola
#endif
