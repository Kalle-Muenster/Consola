/*///////////////////////////////////////////////////////////*\
||                                                           ||
||     File:      ConsolaAuxilary.cpp                        ||
||     Author:    Autogenerated                              ||
||     Generated: 23.02.2022                                 ||
||                                                           ||
\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
#include <settings.h>
#include <.byteOrder.h>
 
using namespace   System;
using namespace   System::IO;
using namespace   System::Threading::Tasks;
using namespace   System::Threading;


#include "ConsolaLogger.hpp"
#include "ConsolaStream.hpp"
#include "ConsolaAuxilary.hpp"


#define TABS for (int i = 0; i < depth; ++i) log->Write( "    " )


Consola::AuxilaryStream::AuxilaryStream( fourCC name )
    : StdStream( Direction::Aux )
    , typ(name)
{
    if (auxeen == nullptr) {
        auxeen = gcnew array<fourCC>(1) { name };
        auxtrm = gcnew array<AuxilaryStream^>(1) { this };
        aux = this;
    }
    else auxtrm[extendRaum(typ, Direction::Inp)] = this;
}

Consola::AuxilaryStream::~AuxilaryStream()
{
    extendRaum( typ, Direction::Out );
}

Consola::AuxXml::AuxXml(void)
    : AuxilaryStream( byteOrder_stringTOfourCC("Xml") )
{
    scope = State::NoScope;
    depth = -1;
    state = nullptr;
    states = gcnew System::Collections::Generic::List<String^>();
}

Consola::AuxXml^
Consola::AuxilaryStream::Xml::get(void)
{
    for( int idx = 0; idx < auxeen->Length; ++idx )
        if( auxeen[idx] == byteOrder_stringTOfourCC("Xml") )
            return (AuxXml^)auxtrm[idx];
    return nullptr;
}

int
Consola::AuxilaryStream::extendRaum( unsigned des, Direction how) {
    switch (how) {
    case Direction::Out: {
        int size = auxeen->Length;
        array<AuxilaryStream^>^ raumExtender = gcnew array<AuxilaryStream^>( auxtrm->Length + 1 );
        array<unsigned>^ nameExtender = gcnew array<unsigned>( auxeen->Length + 1 );
        auxtrm->CopyTo( raumExtender, 0 );
        auxeen->CopyTo( nameExtender, 0 );
        auxtrm = raumExtender;
        auxeen = nameExtender;
        auxeen[size] = des;
        return size;
    } break;
    case Direction::Inp: {
        if (auxtrm->Length > 1) {
            int position = auxeen->Length - 1;
            array<AuxilaryStream^>^ raumExtender = gcnew array<AuxilaryStream^>( auxtrm->Length - 1 );
            array<unsigned>^ nameExtender = gcnew array<unsigned>( auxeen->Length - 1 );
            for( int i = position, n = position - 1; i >= 0; --i, --n ) {
                if( auxeen[i] != des ) {
                    raumExtender[n] = auxtrm[i];
                    nameExtender[n] = auxeen[i];
                } else position = n++;
            }
            auxtrm = raumExtender;
            auxeen = nameExtender;
            return position;
        }
        else {
            auxtrm = nullptr;
            auxeen = nullptr;
            return 0;
        }
    } break;
    default: how = Direction::Err; break;
    }
}

void
Consola::AuxXml::WriteContent( System::String^ format, ...array<Object^>^ content )
{
    if( scope != State::Content )
        NewScope( State::Content );
    Log->Write( format, content );
    Log->Flush();
}

void
Consola::AuxXml::WriteElement( String^ tagname, ...array<String^>^ attribute )
{
    if (scope >= State::Element) {
        NewScope(State::Element);
    }
    ++depth;
    states->Add( state = tagname );
    scope = State::Attribute;
    TABS;
    log->Write( String::Format( "<{0}", tagname ) );
    if( attribute->Length == 0 ) log->Flush();
    for ( int i = 0; i < attribute->Length; ++i ) {
        String^ a = attribute[i]->ToString();
        if (a->Contains("=")) {
            array<String^>^ kv = a->Split('=');
            WriteAttribute( kv[0], kv[1] );
        } else {
            WriteAttribute( a, nullptr );
        }
    }
}

void
Consola::AuxXml::WriteAttribute( String^ name, Object^ value )
{
    if (scope == State::Element) scope == State::Attribute;
    if (scope == State::Attribute) {
        if( value != nullptr ) log->Write( String::Format(" {0}=\"{1}\"", name, value->ToString() ) );
        else log->Write(" " + name);
        log->Flush();
    }
}

void
Consola::AuxXml::WriteNode( System::Xml::XmlNode^ node )
{
    if( scope == State::Content || scope == State::Element || scope == State::Attribute ) {
        NewScope(State::Content);
    } log->WriteLine( node->OuterXml );
    log->Flush();
}

void
Consola::AuxXml::CloseScope( void )
{
    switch( scope ) {
    case State::Content:
    case State::Attribute:
    case State::Element: {
        NewScope( depth >= 0 ? State::Content : State::Document );
    } break;
    case State::Document: {
        scope = State::NoScope;
        depth = -1;
        Log = nullptr;
    } break;
    }
}

void
Consola::AuxXml::NewScope( State newScope )
{
    if( scope == State::NoScope ) {
        scope = State::Document;
        log->WriteLine( "<!xml version=\"1.0\" encoding=\"utf8\">" );
    } switch( scope ) {
    case State::Attribute:
        if( !( (newScope & (State::Element|State::Content)) != State::NoScope ) ) {
            --depth; log->Write( "/" );
        } log->Write( ">\n" );
        log->Flush();
        break;
    case State::Element:
        if( state != nullptr && !(newScope == State::Content) ) {
            TABS;
            log->Write( String::Format( "</{0}>\n", state ) );
        } else log->Write( "/>\n" );
        log->Flush();
        --depth;
        break;
    case State::Comment:
        log->Write( " -->\n" );
        log->Flush();
        --depth;
        break;
    case State::Content:
        TABS;
        log->Write( "</{0}>\n", state );
        log->Flush();
        --depth;
        break;
    case State::CData:
        log->Write( "\"]>\n" );
        log->Flush();
        --depth;
    } scope = newScope;
    if( states->Count > depth + 1 ) {
        states->RemoveAt( depth + 1 );
    } state = states->Count > 0 
            ? states[depth]
            : nullptr;
}


Consola::LogWriter^
Consola::AuxilaryStream::Log::get( void )
{
    return log == nullptr
         ? createLog() : log;
}
void
Consola::AuxilaryStream::Log::set( LogWriter^ value )
{
    if (((log != nullptr) && (log != value)) || (value == nullptr)) {
        closeLog();
    } log = value;
}


Consola::LogWriter^
Consola::AuxXml::Log::get( void )
{
    return log == nullptr
         ? createLog()
         : log;
}
void
Consola::AuxXml::Log::set( LogWriter^ logger )
{
    if (logger == nullptr) {
        closeLog();
    } else {
        log = logger;
    }
}
